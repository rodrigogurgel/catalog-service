spring:
    application:
        name: catalog-service
    kafka:
        consumer:
            bootstrap-servers: ${BOOTSTRAP_SERVERS}
            key-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
            value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
            properties:
                schema.registry.url: ${SCHEMA_REGISTRY_URL}
                basic.auth.credentials.source: USER_INFO
                basic.auth.user.info: ${SCHEMA_REGISTRY_API_KEY}:${SCHEMA_REGISTRY_API_SECRET}
                specific.avro.reader: true
                spring.deserializer.key.delegate.class: org.apache.kafka.common.serialization.StringDeserializer
                spring.deserializer.value.delegate.class: io.confluent.kafka.serializers.KafkaAvroDeserializer
                sasl.mechanism: PLAIN
                sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username='${CLUSTER_API_KEY}' password='${CLUSTER_API_SECRET}';
                security.protocol: SASL_SSL
        producer:
            properties:
                schema.registry.url: ${SCHEMA_REGISTRY_URL}
                basic.auth.credentials.source: USER_INFO
                basic.auth.user.info: ${SCHEMA_REGISTRY_API_KEY}:${SCHEMA_REGISTRY_API_SECRET}
                value.subject.name.strategy: io.confluent.kafka.serializers.subject.RecordNameStrategy
                sasl.mechanism: PLAIN
                sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username='${CLUSTER_API_KEY}' password='${CLUSTER_API_SECRET}';
                security.protocol: SASL_SSL
            key-serializer: org.apache.kafka.common.serialization.StringSerializer
            value-serializer: io.confluent.kafka.serializers.KafkaAvroSerializer
            bootstrap-servers: ${BOOTSTRAP_SERVERS}
            client-id: catalog-service
